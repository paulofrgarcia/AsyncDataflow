HLS toolchains must allow seamless integration with HDL languages, both for legacy code re-use and for flexibility; some design aspects are complicated by HLS semantics and more easily resolved in HDL. \cite{bluespec_bad} excelently describes the problems of integrating Bluespec with Verilog code. Notably, connecting legacy IP modules often require ''wrappers" which trasnlate the native module interface into Bluespec compliant semantics, complicating re-use. Some assumptions (e.g., active high or active low signals) cannot be changed from the HDL domain and require proper modification.
\par More generally, HLS languages must provide the kind of support to Verilog/VHDL that C compilers provide to assembly language. Hierarchical use of HDL modules within HLS semantics, similarly to inline assembly in C code (hierarchy), and seamless interconnection following flexible, configurable ABIs for linking (composition), which allow specifying interfaces, polarities and timing behavior in a flexible way. New generation HLS languages must treat interfaces, not just as port definitions such as in HDLs, but as complex, flexible protocols with parameterizable ABIs to allows seamless interoperability.
