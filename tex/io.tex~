In the software world, the majority of programmers need not concern themselves with the target architecture (exceptions are embedded programmers who must interact directly with hardware). Software is developed in the same way for ARM, IA64 or PowerPC: the compiler toolchain handles appropriate assembly code generation and linking. This is not true for FPGAs. The equivalent of assembly code generation, generating configuration bistream files, is handled by the synthesis tool. But linking, which for software connects applications with initialization/bootstrap code, static and dynamic libraries, is manually performed by hardware designers in function of specific FPGAs (mapping system input/output ports to FPGA pins) and off-chip connections. This part of the design process limits the usage of many HLS toolchains by programmers lacking FPGA expertise, since low-level constraints requiring knowledge of place-and-route tools must be manually specified. HLS toolchains are limited to the FPGA boundaries.
\par With the rise of the platform FPGA, more and more designs will incorporate software running on off-chip processors and accesses to external memories and other peripheral devices. One of the greatest HLS breakthroughs will be automated porting across different FPGA families and boards. FPGA designs will be synthesized like the Linux kernel: specifying an architecture and board through configuration options prior to compilation. Linkers will automatically inject interconnection logic in the design, map system ports to FPGA pins, generate constraint files and invoke place-and-route tools.  
\par It is still a utopic view, far from the current capabilities of HLS toolchains. But we are inexorably moving towards that goal. Perhaps by utilizing \textit{intermediate fabrics} for runtime reconfiguration \cite{coole2010intermediate} or by introducing semantic information to HDL code which allows automatic I/O mapping through typed interfaces \cite{7294024}. Until then, programmers will be limited to vendor-specific ''plug-and-play" platforms or require FPGA-fluent engineers to manage the low level details of generated HLS code. 
